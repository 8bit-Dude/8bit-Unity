;
; Copyright (c) 2018 Anthony Beaucamp.
;
; This software is provided 'as-is', without any express or implied warranty.
; In no event will the authors be held liable for any damages arising from
; the use of this software.
;
; Permission is granted to anyone to use this software for any purpose,
; including commercial applications, and to alter it and redistribute it
; freely, subject to the following restrictions:
;
;   1. The origin of this software must not be misrepresented; you must not
;   claim that you wrote the original software. If you use this software in a
;   product, an acknowledgment in the product documentation would be
;   appreciated but is not required.
;
;   2. Altered source versions must be plainly marked as such, and must not
;   be misrepresented as being the original software.
;
;   3. This notice may not be removed or altered from any distribution.
;
;   4. The names of this software and/or it's copyright holders may not be
;   used to endorse or promote products derived from this software without
;   specific prior written permission.
;

; Original sprite flicker routine by Anthony Beaucamp
; Twin frame graphic mode adapted from Inter-Player
; Date created: 2017/12/21
; Compile with MADS

lists	= $6550
addrTop = $6555
addrBot = $65bd
procs   = $6f50

frame1	= $7010
frame2	= $a010

atract  = $004d
vdslst	= $0200
sdlstl	= $0230

color0	= $02c4
color1	= $02c5
color2	= $02c6
color3	= $02c7
color4	= $02c8

M1POS 	= $d004
M2POS 	= $d005
M3POS 	= $d006
M4POS 	= $d007

gprior	= $d01b
wsync	= $d40a
nmien	= $d40e

/*-------------------------------------------------------------------------------------------------*/
	
	org lists

; Display lists	
dlist:	dta $70,$70,$70
		dta $4e,a(frame1)
		:101 dta $e			
		dta $4e,0,h(frame1+$1000)
		:96 dta $e
		dta $8e				; Invoke DLI with $80
		dta $41,a(dlist)
		
/*-------------------------------------------------------------------------------------------------*/	
		
; Sprite flicker routine
FlickRows	.ds 1
FlickMask	.ds 1
FlickX		.ds 4
FlickY		.ds 4
FlickFrames .ds 8
FlickOffset .ds 1
FlickIndex	.ds 1

initFlicker:
	; Init 5th sprite
	mva #0 FlickIndex
	mva #0 FlickMask
	mva #$9b $ce	; High-byte of 5th sprite's base address ($9b00)
	rts

updateFlicker:	
	; Check that sprites are enabled!
	lda FlickMask
	bne resetPMG5
	rts
	
resetPMG5:
	; Reset pixels of 5th sprite
	ldx FlickOffset	; Offset of 5th sprite ($9b00 ~ $9bff)
	stx $cd
	ldy FlickRows	; Sprite length
	lda #$00		; Reset value
strloop0:	
	sta ($cd),y		
	dey
	bne strloop0	; Loop through till y is 0
	
sprbranch1:
	; Increment 5th sprite index (reset when index becomes 4)
	ldx FlickIndex
	inx	
	cpx #4
	bcc sprbranch2
	ldx #0
	
sprbranch2:
	stx FlickIndex
	
	; Verify sprite is allocated in mask
	lda #$0000001
	cpx #0
	beq bittest
bitshift:
	asl
	dex
	bne bitshift	; Loop through till x is 0 
bittest:
	and FlickMask
	beq sprbranch1
	
setpos:
	; Set x pos. of new 5th sprite
	ldx FlickIndex
	lda FlickX,x  ; Xpos of sprite to A
	sta M4POS
	cpx #0
	adc #1
	sta M3POS
	adc #2
	sta M2POS
	adc #2
	sta M1POS
	
	; Copy frame address to zeropage
	cpx #0
	beq off0
	cpx #1
	beq off1
	cpx #2
	beq off2
off3:
	mva FlickFrames+6 $cb
	mva FlickFrames+7 $cc
	jmp copy
off2:	
	mva FlickFrames+4 $cb
	mva FlickFrames+5 $cc
	jmp copy
off1:	
	mva FlickFrames+2 $cb
	mva FlickFrames+3 $cc
	jmp copy
off0:	
	mva FlickFrames+0 $cb
	mva FlickFrames+1 $cc
	
copy:	
	; Compute screen offset and copy to zeropage
	lda FlickY,x   ; Ypos of sprite to A
	sta FlickOffset
	sta $cd
		
	; Copy frame to screen
	ldy FlickRows	; Sprite length
sprloop1:
	; Transfer values
	lda ($cb),y	
	sta ($cd),y	
	dey
	bne sprloop1	; Loop through till y is 0 
	
return:	
	; All done!
	rts

/*-------------------------------------------------------------------------------------------------*/

	org procs
	
; Toggle for frame blending (ON/OFF)
blendTOG: dta $0

; GFX config backup
nmienBAK  .ds 1
sdlstlBAK .ds 2
color0BAK .ds 1
color1BAK .ds 1
color2BAK .ds 1
color4BAK .ds 1

; Registries backup
regA	.ds 1
regX	.ds 1
regY	.ds 1	
		
.proc StartBITMAP	
	; Backup GFX settings
	mva nmien  nmienBAK
	mwa sdlstl sdlstlBAK
	mva color0 color0BAK
	mva color1 color1BAK
	mva color2 color2BAK
	mva color4 color4BAK
	
	; Setup DLIST and DLI
	sei
	mva	#$c0	nmien
	mwa	#dlist	sdlstl
	mwa	#dli	vdslst
	cli

	; Init Sprite Flicker Routine
	jsr initFlicker
	rts		
.endp

.proc StopBITMAP
	; Kill DLI and restore palette
	sei
	mva	nmienBAK  nmien
	mwa sdlstlBAK sdlstl
	cli
	mva color0BAK color0
	mva color1BAK color1
	mva color2BAK color2
	mva color4BAK color4
	rts
.endp

dli:
	; Backup registers
	sta regA
	stx regX
	sty regY
	
	; Switch buffer
	lda blendTOG
	eor #$1
	sta blendTOG
	bne showframe2

showframe1:	
	; Switch bitmap buffer 1
	mva #$A0 addrTop
	mva #$B0 addrBot	
	jmp done

showframe2:	
	; Switch bitmap buffer 2
	mva #$70 addrTop
	mva #$80 addrBot		
	jmp done
	
done:
	; Flicker 5th sprite (if needed)
	jsr updateFlicker

	; Reset atract (screen saver timer)
	sta atract

	; Restore Registers
	lda regA
	ldx regX
	ldy regY
	rti	
	